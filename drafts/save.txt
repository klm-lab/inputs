// import {
//   checkState,
//   getObjectKeysAsType,
//   populateCommonOptions
// } from "../src/helpers";
// import { InputStateType, ObjState } from "../src/types";
// import { UtilError } from "../src/helpers/error";
//
// /**
//  * Get object with autocomplete
//  * @param obj
//  * @param firstKey
//  * @description Take any object as param, take firstKey which inherits obj key
//  * and return an object with firstkey as key with autocomplete
//  * @author Arnaud LITAABA
//  */
// // Take an object and return an object with key as given key plus autocompletition
// export const getObjectWithAutoComplete = <Obj, FirstKey extends keyof Obj>(
//   obj: Obj,
//   firstKey: FirstKey
// ) => {
//   return {
//     [firstKey]: "56"
//   } as { [key in FirstKey]: string };
// };
//
// /**
//  * Get object with autocomplete with string params
//  * @param keys
//  * @description Take many keys, take firstKey which inherits string | number | symbol
//  * and return an object with firstkey as key with autocomplete
//  * @author Arnaud LITAABA
//  */
// export const getObjectWithAutoCompleteOnString = <
//   FirstKey extends string | number | symbol
// >(
//   keys: FirstKey[]
// ) => {
//   let res = {} as { [key in FirstKey]: string };
//
//   keys.forEach((key) => {
//     res = {
//       ...res,
//       [key]: {
//         name: key,
//         value: "",
//         valid: false,
//         touched: false
//       }
//     };
//   });
//
//   return res;
// };
//
// // eslint-disable-next-line @typescript-eslint/no-unused-vars
// const t = (entry: { [key in string]: string }, key: keyof typeof entry) => {
//   // console.log(entry[key]);
// };
//
// // eslint-disable-next-line @typescript-eslint/no-unused-vars
// function createState<Obj extends ObjState, key extends keyof Obj>(state: Obj) {
//   let res = {} as { [k in key]: InputStateType };
//
//   checkState(state);
//
//   getObjectKeysAsType(state).forEach((key) => {
//     res = {
//       ...res,
//       [key]: {
//         name: key,
//         ...populateCommonOptions(state[key].validate),
//         ...state[key]
//       }
//     };
//   });
//   // we keep ...res to make autocomplete available to user
//   return {
//     ...res,
//     ...handleMatchValidation(res)
//   };
// }
//
// // eslint-disable-next-line @typescript-eslint/no-unused-vars
// function handleMatchValidation(state: ObjState) {
//   const mappedState: ObjState = { ...state };
//
//   for (const stateKey in mappedState) {
//     //We actually are on ONE Input Section for example: confirmPassword
//     if (stateKey in mappedState) {
//       /* we get the key to match with, we are trying to see
//        for example if confirmPassword want to match its validate to some key
//       */
//       const matchKey = mappedState[stateKey].validate?.match as string;
//       /* we check if validate and key to match exist else we throw error
//        * For example, we check if state.confirmPassword.validate exists, and we check if matchKey
//        * state.confirmPassword.validate.match exists
//        */
//       if (mappedState[stateKey].validate && matchKey) {
//         if (!(matchKey in mappedState)) {
//           throw UtilError({
//             name: "Index Error",
//             message: `'${matchKey}' does not exist in your state key`,
//             stack: `${stateKey}.validate.match = ${matchKey}`,
//             state
//           });
//         }
//
//         /* we merge current input section (confirmPassword) validate who already have the match key
//          * with the matched input section validate (password) because the matchKey is password
//          * Since state[stateKey which is confirmPassword].validate.matchKey = password, there is no need to add it again
//          * For example: we copy all property from password validate to confirmPassword validate because confirmPassword validate
//          * match with password validate. Remember stateKey is confirmPassword amd matchedKey is password
//          */
//         mappedState[stateKey] = {
//           ...mappedState[stateKey],
//           validate: {
//             ...mappedState[matchKey].validate,
//             ...mappedState[stateKey].validate
//           }
//         };
//         /* We add a new match key to input section who is the matched one and the match is the key of current input section
//          * For example, we copy validate from password to confirmPassword. Perfect, now we need to add th match property to
//          * password also. So password can match in return confirmPassword.
//          * Remember stateKey is confirmPassword amd matchedKey is password
//          */
//         mappedState[matchKey] = {
//           ...mappedState[matchKey],
//           validate: {
//             ...mappedState[matchKey].validate,
//             match: stateKey
//           }
//         };
//       }
//     }
//   }
//   return { ...mappedState };
// }

// import { ArrayInput, Dispatch, SetStateAction, ValuesType } from "../src/types";
// import { UtilError } from "../src/helpers/error";
// import { checkStateInput, checkStateProperty, initialArrayCheck, populateCommonOptions } from "../src/helpers/tools";
//
// function withArrayInputs<Obj extends ArrayInput[]>([state, setState]: [
//   Obj,
//   Dispatch<SetStateAction<Obj>>
// ]) {
//   if (state?.constructor.name !== "Array") {
//     throw UtilError({
//       name: "StateError",
//       message: "The state is not an array",
//       state
//     });
//   }
//   const res: ArrayInput[] = [];
//
//   state.forEach((s) => {
//     initialArrayCheck(s);
//     checkStateProperty(s, s);
//     checkStateInput(s);
//     res.push({ ...populateCommonOptions(), ...s });
//   });
//
//   // res = checkArrayMatchState(res);
//
//   function stateChange(name: string | undefined, value: ValuesType) {
//     return; //onObjectStateChange(name, value, setState);
//   }
//
//   return [res, stateChange] as [ArrayInput[], typeof stateChange];
// }

//matchInputValidation
// eslint-disable-next-line @typescript-eslint/no-unused-vars
// function likeInputValidation(
//   state: ObjState,
//   name: string,
//   matchKey: string
// ) {
//   haveMatch(state, name, matchKey);
//   /*
//    * We create a match result with default value.
//    * all matchKeys = [], lastMatched = current matchKey
//    * validate: current MatchKey validate
//    * */
//   let matchResult: MatchResultType = {
//     matchKeys: [],
//     lastMatched: matchKey,
//     validate: state[matchKey].validate
//   };
//
//   /*
//    * We check if the matched input also match someone until find the last one who does have a match property
//    * and use last not matched validate to match all input in the hierarchy.
//    * We add __ for validate tool. See Class validate in ../validate.CheckMatch()
//    * */
//   try {
//     const deepMatch = new deepMatch(state);
//     deepMatch.startMatching(matchKey);
//     matchResult = deepMatch.result;
//   } catch (_) {
//     throw UtilError({
//       name: "Matching Error",
//       message: `It seems that we have infinite match here. Please make sure Input does not match each other and the last matched input does not match anyone`,
//       state: state
//     });
//   }
//
//   /*
//    * For every matched key , We set two properties.
//    * - lastMatched input validate
//    * - trackingMatching.
//    * The input validate is the validate defined by the user (We just want to keep the match key of the user)
//    * We add our result validate and for trackMatching, we put the current name,
//    * all matchKeys found without the value itself and the last matched.
//    * For example. if name match firstname and firstname match username and username match something,
//    * the result of the matchKeys on name name are ["firstname", "username"] and lastMatched is something.
//    * We loop through the result and set trackMatching to ["name",custom,"something"]
//    * custom  = username if one of the result is firstname and firstname the one the result if username.
//    * We don't want an input to match himself
//    * */
//   matchResult.matchKeys.forEach((v) => {
//     state[v].validate = {
//       ...state[v].validate,
//       ...matchResult.validate,
//       __: setTrackingMatching(state[v], [
//         name,
//         ...matchResult.matchKeys.filter((v) => v !== v),
//         matchResult.lastMatched
//       ])
//     };
//   });
//
//   /*
//    * trackMatching for the name itself is the result and the last matched
//    * ["firstname","username","something"]
//    * */
//   state[name].validate = {
//     ...matchResult.validate,
//     match: matchKey,
//     __: setTrackingMatching(state[name], [
//       ...matchResult.matchKeys,
//       matchResult.lastMatched
//     ])
//   };
//
//   /*
//    * trackMatching for the lastMatched is the name and result
//    * ["name","firstname","username"]
//    * */
//   state[matchResult.lastMatched].validate = {
//     ...matchResult.validate,
//     __: setTrackingMatching(state[matchResult.lastMatched], [
//       name,
//       ...matchResult.matchKeys
//     ])
//   };
//
//   return state;
// }

// function withArrayInputs<Obj extends ArrayInput[]>([
//   defaultState,
//   defaultSetState
// ]: [Obj, Dispatch<SetStateAction<Obj>>]) {
//   checkStateArrayAndInputObjectAndTargetValid(defaultState);
//
//   let state: ArrayInput[] = [];
//
//   defaultState.forEach((s) => {
//     state.push({ ...populateCommonOptions(s.validate), ...s });
//   });
//
//   // this need to be done after populate or after set things up
//   const validateState = checkMatchValidationAndAllProperties(
//     ato(state)
//   );
//
//   state = transform(validateState);
//
//   function setState(index: number, value: ValuesType) {
//     return onArrayStateChange(index, value, defaultSetState);
//   }
//
//   return [state, setState] as [ArrayInput[], typeof setState];
// }

// /**
//  * @name withObjectInputs
//  * @param defaultState
//  * @param defaultSetState
//  * @param as
//  * @description Create a generic type Obj and key type.
//  * Extends it types with Input types and extends key type with the keyof the Obj previously created.
//  * Pass the type Obj to the param state.
//  * Create the output res as an array of object cast as {[key in "user key typed when calling the function"]: InputStateType}
//  * and setState which will update the state
//  * Call the helper getObjectKeysAsType which return all key of object as type and for each key we populate the res,
//  * therefore we have autocomplete based on user key
//  * @author Arnaud LITAABA
//  */
// function withObjectInputs<Obj extends ObjState, key extends keyof Obj>([
//   defaultState,
//   defaultSetState
// ]: [Obj, Dispatch<SetStateAction<Obj>>]) {
//   checkStateObjectAndTargetUndefinedOrValid(defaultState);
//
//   let state = {} as { [k in key]: Input };
//
//   getObjectKeysAsType(defaultState).forEach((key) => {
//     state = {
//       ...state,
//       [key]: {
//         ...populateCommonOptions(defaultState[key].validate),
//         ...defaultState[key],
//         name: key
//       }
//     };
//   });
//
//   // this need to be done after populate or after set things up
//   const validatedState = checkMatchValidationAndAllProperties(state);
//
//   function setState(name: string | undefined, value: ValuesType) {
//     return onObjectStateChange(name, value, defaultSetState);
//   }
//
//   // we keep ...state to make autocomplete available to user
//   return [{ ...state, ...validatedState }, setState] as [
//     { [k in key]: Input },
//     typeof setState
//   ];
// }

// function initValidAndTouch(entry: Input | ArrayInput) {
//   const validate = entry.validate;
//   const value = entry.value;
//   if (typeof validate === "undefined") {
//     return true;
//   }
//   if (Object.keys(validate).length <= 0) {
//     return true;
//   }
//   return !["", 0, null, undefined].includes(value);
// }

// function onObjectStateChange<Obj extends Input>(
//   name: string | undefined,
//   value: ValuesType,
//   setState: Dispatch<SetStateAction<Obj>>
// ) {
//   setState((prevState: Obj) => {
//     if (
//       typeof name === "string" &&
//       typeof prevState.inputs[name] !== "undefined"
//     ) {
//       const clonedData = { ...prevState.inputs };
//       const inputEl = {
//         ...clonedData[name as string]
//       };
//       inputEl.value = value;
//       inputEl.touched = true;
//       const { validatedData, valid, errorMessage } = validate(
//         clonedData,
//         name as string,
//         value
//       );
//       inputEl.valid = valid;
//       inputEl.errorMessage = errorMessage;
//       const updatedState = {
//         ...validatedData,
//         [name as string]: { ...inputEl }
//       };
//       const formIsValid = stateIsValid(updatedState);
//       return {
//         inputs: updatedState,
//         formIsValid
//       } as Obj;
//     }
//     throw UtilError({
//       name: "State update Error",
//       message: `The name '${name}' is not present in the state`
//     });
//   });
//   return;
// }

// function onArrayStateChange<Obj extends ArrayInputs>(
//   index: number,
//   value: ValuesType,
//   setState: Dispatch<SetStateAction<Obj>>
// ) {
//   if ((typeof index as unknown) !== "number") {
//     throw UtilError({
//       name: "State update Error",
//       message: "Index is not a number",
//       stack: `${index}`
//     });
//   }
//   setState((prevState: Obj) => {
//     if (typeof prevState.inputs[index] === "undefined") {
//       throw UtilError({
//         name: "State update Error",
//         message: `Wrong index provided '${index}'`,
//         stack: `'${index}'`
//       });
//     }
//     const clonedData = [...prevState.inputs];
//     const inputEl = clonedData[index];
//     inputEl.value = value;
//     inputEl.touched = true;
//     const { validatedData, valid, errorMessage } = validate(
//       ato(clonedData),
//       inputEl.name,
//       value
//     );
//     inputEl.valid = valid;
//     inputEl.errorMessage = errorMessage;
//     const result = transform(validatedData);
//     result[index] = inputEl;
//     const formIsValid = stateIsValid(validatedData);
//     return { inputs: result, formIsValid } as Obj;
//   });
// }

// /**
//  * Get object key as type
//  * @param obj
//  * @description Take any object as param and return an array of it's key
//  * Thoses keys can be used as type
//  * @author Arnaud LITAABA
//  */
// function getObjectKeysAsType<Obj extends object>(obj: Obj): (keyof Obj)[] {
//   return Object.keys(obj) as (keyof Obj)[];
// }
