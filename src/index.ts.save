import type {
  ArrayStateOutput,
  Input,
  ObjInput,
  ObjStateOutput,
  StateType,
  StringStateOutput,
  ValuesType
} from "./types";
import { cm, e, mr, rs, t, vs } from "./util";
import { v, va } from "./util/validation";
import { useMemo } from "react";
import { H } from "./util/helper";
import { createStore } from "aio-store/react";

const populate = (state: any, type: StateType): any => {
  const final = {} as ObjInput;
  const helper = new H();
  for (const stateKey in state) {
    const parseKey = type === "object" ? stateKey : state[stateKey].id;
    const key = crypto.randomUUID();
    const v = {
      ...cm(state[stateKey]),
      ...state[stateKey],
      ...(type === "object" ? { id: stateKey, key } : { key })
    };
    final[parseKey] = v;
    helper.s[parseKey] = { ...v };
  }
  const entry = helper.clean(mr(final, helper));
  const isValid = vs(entry);
  helper.iv = isValid;
  return { entry, isValid, helper };
};

const inputs = (
  initialState: any,
  type: StateType,
  asyncDelay: number,
  selective?: string
) => {
  const inputStores = useMemo(
    () => createStore(populate(initialState, type)),
    []
  );

  const { entry, isValid } = inputStores();

  const { set, reset, to, getValues } = useMemo(() => {
    const to = () => {
      const en = inputStores.get("entry");
      return type === "object" ? en : t(en, "array");
    };
    return {
      set: (input: Input, value: ValuesType) => {
        return onChange(
          // entry is used to get id so, no need to add it as dependency
          selective ? entry[selective] : input,
          selective ? input : value,
          inputStores,
          asyncDelay
        );
      },
      reset: () => {
        inputStores.set((ref) => {
          // just for reset, no need to add entry as dependency;
          ref.entry = rs({ ...entry });
          ref.isValid = inputStores.get("helper").iv;
        });
      },
      to: type === "object" ? { toArray: to } : { toObject: to },
      getValues: () => {
        return e(inputStores.get("entry"));
      }
    };
  }, []);

  const inputs = selective ? entry[selective] : entry;

  return [
    type === "object" ? inputs : t(inputs, "array"),
    set,
    { isValid, reset, getValues, ...to }
  ];
};

const asyncCallback = ({
  valid: asyncValid,
  em: asyncErrorMessage,
  entry,
  inputStores
}: any) => {
  inputStores.set((ref: any) => {
    const clonedData = { ...ref.entry };
    // revalidate input
    const { valid, em } = v(
      inputStores,
      clonedData,
      entry.id as string,
      clonedData[entry.id as string].value
    );
    clonedData[entry.id as string].valid = valid && asyncValid;
    clonedData[entry.id as string].errorMessage = valid
      ? asyncErrorMessage
      : em;
    clonedData[entry.id as string].validating = false;
    ref.entry = clonedData;
    ref.isValid = vs(clonedData);
  });
};

const onChange = (
  input: Input,
  value: ValuesType,
  inputStores: any,
  asyncDelay: number
) => {
  inputStores.set((ref: any) => {
    const clonedData = { ...ref.entry };
    const { valid, em } = v(inputStores, clonedData, input.id as string, value);
    clonedData[input.id as string].value = value;
    clonedData[input.id as string].touched = true;
    clonedData[input.id as string].valid = input.validation?.async
      ? false
      : valid;
    clonedData[input.id as string].errorMessage = em;
    /* if it is valid then if async is true, we set validating to true otherwise false
     * valid === false mean no need to call async,
     * valid === true means we can call async if async is set to true by the user.
     *
     * validating prop is responsible to show async validation loading
     * */
    clonedData[input.id as string].validating = valid
      ? !!input.validation?.async
      : false;

    if (valid && input.validation?.async) {
      va(
        inputStores,
        clonedData,
        input.id as string,
        value,
        asyncDelay,
        asyncCallback
      );
    }

    ref.entry = clonedData;
    ref.isValid = vs(clonedData);
  });
};

function useInputs<S>(
  initialState: ObjInput & S,
  asyncDelay?: number
): ObjStateOutput<keyof S>;
function useInputs(
  initialState: Input[],
  asyncDelay?: number
): ArrayStateOutput;
function useInputs(
  initialState: (string | Input)[],
  asyncDelay?: number
): ArrayStateOutput;
function useInputs(
  initialState: string,
  asyncDelay?: number
): StringStateOutput;

function useInputs(initialState: any, asyncDelay: number = 800): any {
  if (Array.isArray(initialState)) {
    return inputs(
      initialState.map((entry, i) =>
        typeof entry === "string"
          ? { id: entry }
          : entry.id
          ? entry
          : { id: `input_${i}`, ...entry }
      ),
      "array",
      asyncDelay
    );
  }
  if (typeof initialState === "string") {
    return inputs({ [initialState]: {} }, "object", asyncDelay, initialState);
  }
  return inputs(initialState, "object", asyncDelay);
}

export { useInputs };
